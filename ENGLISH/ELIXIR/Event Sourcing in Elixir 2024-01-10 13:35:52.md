```elixir
defmodule EventSourcing.Aggregate do
  @enforce_keys [:module, :initial_state]
  defstruct [:module, :initial_state]

  def init(%__MODULE__{} = aggregate, events) do
    Enum.reduce(events, aggregate.initial_state, fn event, state ->
      aggregate.module.apply(:apply_event, [event, state])
    end)
  end

  def apply_event(aggregate, event) do
    aggregate.module.apply(:apply_event, [event, aggregate.initial_state])
  end
end

defmodule EventSourcing.EventStore do
  @enforce_keys [:events]
  defstruct [:events]

  def new(events) do
    %__MODULE__{events: events}
  end

  def append(event_store, event) do
    %__MODULE__{events: [event | event_store.events]}
  end

  def get(event_store, id) do
    Enum.find(event_store.events, fn event -> event.id == id end)
  end
end

defmodule EventSourcing.CommandBus do
  @enforce_keys [:event_store, :aggregates]
  defstruct [:event_store, :aggregates]

  def new(event_store, aggregates) do
    %__MODULE__{event_store: event_store, aggregates: aggregates}
  end

  def handle_command(command_bus, command) do
    aggregate = Enum.find(command_bus.aggregates, fn aggregate -> aggregate.module == command.aggregate end)

    events = aggregate.module.apply(:handle_command, [command, aggregate.initial_state])

    Enum.each(events, fn event ->
      event_store = EventSourcing.EventStore.append(command_bus.event_store, event)
      aggregate = EventSourcing.Aggregate.apply_event(aggregate, event)
    end)
  end
end

defmodule EventSourcing.BankAccount do
  @enforce_keys [:balance]
  defstruct [:balance]

  def apply_event("Deposit", %__MODULE__{balance: balance}, amount) do
    %__MODULE__{balance: balance + amount}
  end

  def apply_event("Withdraw", %__MODULE__{balance: balance}, amount) do
    %__MODULE__{balance: balance - amount}
  end

  def handle_command("CreateAccount", %__MODULE__{}, amount) do
    [%EventSourcing.Event{type: "Deposit", amount: amount}]
  end

  def handle_command("Deposit", %__MODULE__{balance: balance}, amount) do
    [%EventSourcing.Event{type: "Deposit", amount: amount}]
  end

  def handle_command("Withdraw", %__MODULE__{balance: balance}, amount) do
    if amount <= balance do
      [%EventSourcing.Event{type: "Withdraw", amount: amount}]
    else
      []
    end
  end
end

event_store = EventSourcing.EventStore.new([])
aggregates = [EventSourcing.Aggregate.new(EventSourcing.BankAccount, [])]
command_bus = EventSourcing.CommandBus.new(event_store, aggregates)

command_bus.handle_command(%EventSourcing.Command{aggregate: EventSourcing.BankAccount, type: "CreateAccount", amount: 100})
command_bus.handle_command(%EventSourcing.Command{aggregate: EventSourcing.BankAccount, type: "Deposit", amount: 50})
command_bus.handle_command(%EventSourcing.Command{aggregate: EventSourcing.BankAccount, type: "Withdraw", amount: 75})

aggregate = Enum.find(aggregates, fn aggregate -> aggregate.module == EventSourcing.BankAccount end)
IO.puts(aggregate.initial_state.balance) # 75

```

This code implements a simple event sourcing system in Elixir. The `EventSourcing.Aggregate` module defines an aggregate, which is a collection of objects that are related to each other and share a common state. The `EventSourcing.EventStore` module defines an event store, which is a repository for events. The `EventSourcing.CommandBus` module defines a command bus, which is responsible for handling commands and dispatching them to the appropriate aggregates. The `EventSourcing.BankAccount` module defines a bank account aggregate.

The `event_store` variable is an instance of the `EventSourcing.EventStore` module. The `aggregates` variable is a list of instances of the `EventSourcing.Aggregate` module. The `command_bus` variable is an instance of the `EventSourcing.CommandBus` module.

The `command_bus.handle_command` function is called to handle a command. The `command` argument is an instance of the `EventSourcing.Command` module. The `aggregate` variable is the aggregate that is associated with the command. The `events` variable is a list of events that are generated by the aggregate in response to the command.

The `event_store.append` function is called to append the events to the event store. The `aggregate.apply_event` function is called to apply the events to the aggregate.

The `aggregate.initial_state.balance` property is used to get the current balance of the bank account.

This code demonstrates how to use event sourcing to implement a bank account. Event sourcing is a technique for storing data in a way that makes it easy to reconstruct the history of changes to the data. This can be useful for a variety of applications, such as auditing, debugging, and data recovery.